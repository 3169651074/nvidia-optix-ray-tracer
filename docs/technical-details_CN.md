# 技术细节

## 架构概述

RendererOptiX 采用分层架构设计，从底层到上层包括：OptiX 渲染层、图形 API 抽象层、渲染器接口层和应用层

## OptiX 渲染管线

### 上下文初始化

OptiX 设备上下文是渲染的核心，负责管理所有 OptiX 资源：

```cpp
OptixDeviceContext createContext(const std::string & cacheFilePath, bool isDebugMode)
```

- 使用 CUDA 设备创建 OptiX 上下文
- 配置缓存路径以加速着色器编译
- 可选启用验证模式

## 加速结构

### 几何加速结构 (GAS)

GAS 用于加速单个几何体类型的查询：

- **球体 GAS**：使用内置球体求交器
- **三角形 GAS**：使用内置三角形求交器
- **粒子 GAS**：每个 VTK 粒子构建一个三角形 GAS

构建过程：

1. 准备几何体数据（SOA 格式）
2. 设置构建输入
3. 计算所需内存
4. 分配设备内存
5. 构建加速结构

### 实例加速结构 (IAS)

IAS 将多个 GAS 组合成场景：

- 每个 VTK 文件对应一个 IAS
- IAS 包含额外几何体实例和所有粒子实例
- 支持动态更新实例变换矩阵

## 着色器模块

### 模块创建

项目使用三个 OptiX 模块：

1. **自定义模块**：从 PTX 文件加载，包含用户定义的着色器
2. **内置球体模块**：OptiX 内置球体求交器
3. **内置三角形模块**：OptiX 内置三角形求交器

### 程序组

创建六个程序组：

- `raygen`：光线生成程序
- `miss`：未命中处理程序
- `chSphereRough`：球体粗糙材质最近命中
- `chSphereMetal`：球体金属材质最近命中
- `chTriangleRough`：三角形粗糙材质最近命中
- `chTriangleMetal`：三角形金属材质最近命中

## 着色器绑定表 (SBT)

SBT 将程序组与场景几何体关联：

```text
SBT 结构：
├── RayGen 记录（1个）
├── Miss 记录（1个）
└── HitGroup 记录（N个）
    ├── 额外球体记录
    ├── 额外三角形记录
    └── VTK 粒子记录（每个粒子一个）
```

每个记录包含：

- 程序组句柄
- 参数数据（材质索引、几何数据指针等）

## 光线追踪流程

### RayGen 程序

1. 计算像素坐标对应的光线方向
2. 初始化光线载荷（颜色、深度等）
3. 调用 `optixTrace` 发射光线
4. 处理返回结果
5. 写入颜色缓冲区

### ClosestHit程序

1. 读取几何体数据
2. 计算交点法线
3. 根据材质类型选择着色模型
4. 递归发射反射/折射光线
5. 返回着色结果

### Miss程序

返回背景颜色

## 图像降噪

使用 OptiX AI Denoiser（一个基于卷积神经网络的降噪器）减少光线追踪噪点：

1. **输入缓冲区**：
   - 颜色缓冲区（主输入）
   - 法线缓冲区（引导）
   - 反照率缓冲区（引导）

2. **降噪过程**：
   - 分配降噪器状态和临时缓冲区
   - 调用 `optixDenoiserInvoke`
   - 将结果复制到输出缓冲区

3. **输出**：降噪后的颜色缓冲区

## 内存管理

### 数据结构

#### SOA (Structure of Arrays) 布局

几何体数据使用 SOA 格式存储，提高 GPU 访问效率：

```cpp
//球体数据
float3 * dev_centers;  //所有球心连续存储
float * dev_radii;     //所有半径连续存储

//三角形数据
float3 * dev_vertices;  //所有顶点连续存储（3*count）
float3 * dev_normals;   //所有法线连续存储（3*count）
```

### 页面锁定内存

实例数组使用页面锁定内存（Pinned Memory）：

- 加速 CPU-GPU 数据传输
- 支持异步传输
- 用于频繁更新的数据

### 内存分配策略

1. **几何数据**：使用普通设备内存（`cudaMalloc`）
2. **实例数组**：使用页面锁定内存（`cudaMallocHost`）
3. **加速结构**：由 OptiX 管理
4. **缓冲区**：使用 CUDA 数组（与图形 API 互操作）

## 图形 API 集成

### CUDA-图形 API 互操作

使用 CUDA 图形 API 互操作将 OptiX 渲染结果传递给图形 API，并使用SDL显示渲染结果：

#### OpenGL

- 注册 OpenGL 纹理
- 映射资源
- 使用后解映射

#### Vulkan

使用 Vulkan 外部内存扩展：

- 创建支持外部内存的 Vulkan 图像
- 获取内存句柄
- 在 CUDA 中导入内存

#### Direct3D

使用 Direct3D 共享资源：

- 创建共享纹理
- 使用 `cudaGraphicsD3D11RegisterResource` 或 `cudaGraphicsD3D12RegisterResource`
- 映射和解映射资源

### 窗口管理

使用 SDL2 进行窗口和输入管理：

- 创建窗口和图形上下文
- 处理键盘和鼠标输入
- 管理事件循环

## VTK 数据处理

### 序列文件格式

VTK 序列文件是 JSON 格式：

```json
{
  "file-series-version": "1.0",
  "files": [
    {"name": "file0.vtk", "time": 0.0},
    {"name": "file1.vtk", "time": 0.1},
    ...
  ]
}
```

## 缓存系统

### 缓存文件格式

在Mesh模式下，每个 VTK 文件对应一个缓存文件：

```text
particleXX.cache:
  [粒子总数: size_t]
  粒子#0:
    [ID: size_t]
    [速度: float3]
    [顶点数: size_t]
    [顶点数组: float3 * N]
    [法线数组: float3 * N]
  粒子#1:
    ...
```

### 缓存优势

- 避免重复解析 VTK 文件
- 二进制格式，读取速度较快
- 支持多线程并行加载

### 数据转换

VTK 数据转换为渲染器内部格式：

1. **读取 VTK 文件**：使用 VTK 库解析
2. **提取粒子数据**：获取每个粒子的 Cell 数据
3. **转换为三角形**：将 Cell 转换为三角形网格
4. **计算法线**：为每个三角形计算法线
5. **存储到设备内存**：拷贝到 GPU

## 材质系统

### 材质类型

#### 粗糙材质 (Rough)

使用 Lambertian 漫反射模型：

- 反照率颜色决定漫反射颜色
- 完全漫反射，无镜面反射

#### 金属材质 (Metal)

使用 Cook-Torrance 微表面模型：

- 反照率颜色决定金属颜色
- Fuzz 参数控制表面粗糙度
- 支持镜面反射

### 材质索引

材质数组组织：

```text
[额外 Rough 材质] [额外 Metal 材质] [VTK Rough 材质] [VTK Metal 材质]
```

VTK 粒子材质索引需要加上额外材质的偏移量。

## 性能优化

### 加速结构优化

1. **GAS**：
   - `OPTIX_BUILD_FLAG_ALLOW_COMPACTION`：压缩加速结构以节省显存
   - `OPTIX_BUILD_FLAG_PREFER_FAST_TRACE`：优化追踪性能

2. **IAS**：
   - `OPTIX_BUILD_FLAG_ALLOW_UPDATE`：允许增量更新
   - 每个VTK文件仅构建一次，在帧之间更新IAS而非重建

### 内存优化

1. **数据布局**：使用 SOA 提高缓存效率
2. **内存复用**：避免频繁分配释放
3. **页面锁定内存**：使用页面锁定内存存放主机端实例数组，提升拷贝效率，并可使用CUDA流扩展为双缓冲

### 渲染优化

1. **降噪器**：通过降噪消除光线追踪的噪点。当前实现每像素采样1次
2. **递归深度限制**：限制光线递归深度（当前为 5）
3. **自适应采样**：可根据需要实现自适应采样

## 调试支持

### OptiX 验证模式

启用验证模式可以检测：

- 无效的加速结构
- 着色器参数错误
- 内存访问越界

### 图形 API 调试

- OpenGL：使用 `glDebugMessageCallback`
- Vulkan：启用验证层
- Direct3D：使用调试设备

启用调试模式后，控制台中会打印调试信息

### 日志系统

使用 SDL 日志系统输出渲染器信息，包括：

- 配置解析
- 数据加载进度
- 错误信息

## 限制

1. **单 GPU**：不支持多 GPU 渲染
2. **材质模型简化**：使用简化的物理材质模型
3. **无体积渲染**：不支持体积数据渲染

## 未来改进方向

1. **更复杂的材质**：实现更多物理材质模型和光源
2. **重要性采样**：对光源进行重要性采样，提升图像质量
3. **体积渲染**：支持体积数据的光线追踪
4. **多GPU支持**：分布式渲染，分块渲染
5. **对象选择**：渲染中支持选中粒子，查看其实时信息
6. **实时编辑**：3D编辑器，支持运行时修改场景
